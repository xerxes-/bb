âœ… Web Cache Poisoning

* Goal: Inject a malicious or manipulated response into the cache.
* Impact: Affects all users who access the poisoned cached content.
* Example: Injecting a `X-Forwarded-Host` header to get a cached response with a malicious script â€” served to everyone.


âœ… Web Cache Deception

* Goal: Trick the server and cache into storing user-specific (private) content as if it's public.
* Impact: Affects individual users, but the attacker can access someone else's cached data.
* Example: Victim visits `/profile.php/random.jpg`, which gets cached. Attacker accesses same URL later and gets victimâ€™s private page.

-

Web cache poisoning involves two phases:

1. Attacker finds a way to get the server to include a harmful payload in its response.
2. They make sure this response gets cached and served to others.

It can be used to spread attacks like XSS, JavaScript injection, or open redirects.

-

Constructing a web cache poisoning attack

*Involves the following steps:

    1. Identify and evaluate unkeyed inputs
    2. Elicit a harmful response from the back-end server
    3. Get the response cached

-

ğŸ” Normal Cache Behavior:

Cache uses the cache key (usually made from URL, method, sometimes headers) to decide:

    "Have I seen this request before?"

    "If yes, serve cached response."


ğŸ”“ What Happens with Unkeyed Inputs:

    You send an unkeyed input (e.g., X-Forwarded-Host: attacker.com) that changes the serverâ€™s response, but doesnâ€™t affect the cache key.

    The cache still stores that altered response under the normal key (e.g., just /home).

    Now, future users who visit /home get the malicious (poisoned) version â€” even though they never sent that unkeyed input.


âœ… So Whatâ€™s New/Dangerous?

You smuggle malicious behavior into the cache by tricking it â€” the cache thinks it's a normal response, but it actually contains injected content.





ğŸ“¦ You:

Send a request like:

```
GET / HTTP/1.1  
Host: victim.com  
X-Forwarded-Host: attacker.com
```


ğŸ”§ Now What *Could* Happen?

Some websites (especially behind proxies or load balancers) trust the `X-Forwarded-Host` header.

If they do, they might use it to:

1. Build links:

   * Instead of using `victim.com`, they build links like:

     ```
     https://attacker.com/reset?token=abc123
     ```

2. Do redirects:

   * When you log in or out, it redirects you to `attacker.com`

3. Cache responses:

   * If the page uses `X-Forwarded-Host` to decide what content to return, but the cache ignores it, the wrong content might get stored.


ğŸ§  Why It Matters:

Letâ€™s say the site creates an email link:

> "Click here to reset your password: https\://attacker.com/reset?token=abc"

That's your header controlling their link = big problem.
Attackers can use this to:

* Steal tokens (phishing)
* Poison cache
* Fake pages or links


âœ… Final Summary:

> `X-Forwarded-Host: attacker.com` tricks the server into thinking the original request came from attacker.com. If the server uses that info in links or redirects, it can lead to serious bugs.






âœ… Realistic Explanation:


Original (before poisoning):

```html
<script src="https://victim.com/app.js"></script>
<script src="https://victim.com/ui.js"></script>
```

Letâ€™s say the web app generates URLs like:

```html
<script src="https://{{Host}}/app.js"></script>
<script src="https://victim.com/ui.js"></script>
```

* The first one uses the `Host` dynamically (maybe built from `X-Forwarded-Host`)
* The second one is hardcoded or safe


ğŸ”¥ Attacker sends:

```http
X-Forwarded-Host: attacker.com
```

Now the app builds:

```html
<script src="https://attacker.com/app.js"></script>  â† attacker controls this
<script src="https://victim.com/ui.js"></script>     â† still from victim.com
```

Because only the dynamic ones change.


âœ… TL;DR:

* Not everything becomes `attacker.com`
* Only the parts that use the unkeyed input (`Host`) get poisoned
* So itâ€™s very common to see a mix: some scripts still from `victim.com`, one from `attacker.com`

This mix can still be enough to fully compromise the user.

-

*

1.	ğŸ” Identify and evaluate unkeyed inputs


Web cache poisoning relies on unkeyed inputs â€” parts of a request (like headers) that affect the response but are ignored by the cache when deciding what to serve.


âœ… Goal:

Find such inputs so you can inject a payload that gets cached and served to others.


ğŸ§ª How to Find Unkeyed Inputs

* Manual: Add random headers or parameters to a request. If they change the response but the cache still hits â†’ theyâ€™re unkeyed.
* Use tools like Burp Comparer to spot differences between responses.


âš™ï¸ Automate with Param Miner

* Add Param Miner from Burpâ€™s BApp Store.
* Right-click a request â†’ "Guess headers"
* It tests many headers to see which affect responses.
* Results show up in:

  * Issues tab (Burp Pro)
  * Output tab (Burp Community)


 âš ï¸ Caution (Donâ€™t Poison Real Users!)

When testing, add a cache buster (e.g., `?nocache=1234`) to avoid affecting real users.
Param Miner can also do this automatically.



2. Elicit a harmful response from the back-end server

Once you find an unkeyed input, check how the server uses it.
If the input shows up in the response (especially unsanitized), or affects other content, it could be used to poison the cache.


ğŸ§ª Example:

You send:

```http
GET /home  
X-Forwarded-Host: attacker.com
```

Server responds with:

```html
<a href="https://attacker.com/logout">Logout</a>
```

âœ… If this response gets cached, every user who visits `/home` will now see a link to attacker.com â€” this is web cache poisoning.



3. Get the response cached

Triggering a harmful response is only useful if it gets cached â€” and that can be tricky.

Caching depends on things like:

    URL path or extension

    Content type

    Status code

    Response headers

ğŸ§ª Youâ€™ll need to test different pages and inputs to see what gets cached.
Once you manage to cache your malicious response, youâ€™re ready to target users.

-

âœ… Step-by-Step of a Cache Poisoning Attack(response is cached)


ğŸ§‘â€ğŸ’» 1. Attacker sends this:

```http
GET /home
Host: victim.com
X-Forwarded-Host: attacker.com
```

* `X-Forwarded-Host` is unkeyed (ignored by cache)
* But the server uses it to build part of the HTML


ğŸ’¥ Server responds with:

```html
<script src="https://attacker.com/app.js"></script>
```

âœ… This response gets cached by the server under the URL `/home`


ğŸ‘¥ 2. Now a normal user sends:

```http
GET /home
Host: victim.com
```

They do not send any special headers.

BUT â€” because the cached version of `/home` already exists (from the attackerâ€™s request)...


ğŸ’£ The cache returns:

```html
<script src="https://attacker.com/app.js"></script>
```

Even though this user never used `attacker.com` â€” they got a poisoned response from cache.


âœ… So When We Say:

> `GET /home` â†’ gets served with the attacker-controlled script

It means:
The normal request to `/home` returns a malicious page, because the cached version was poisoned earlier.


-


âœ… When the response *is cached (successful poisoning):*\*

* Attacker sends a request with unkeyed input (`X-Forwarded-Host: attacker.com`)
* Server builds a malicious response (e.g., with attacker.com links)
* Cache stores this response under `/home`
* Now, all users visiting `/home` get the poisoned version

ğŸ§¨ Impact: Attack spreads to everyone using the cached page.


âŒ When the response is *not cached:*\*

* Attacker still gets the malicious response
* But the cache doesn't store it (due to cache headers, status code, etc.)
* Future users get a fresh, clean response from the server

ğŸ”’ Impact: The attack only affects the attackerâ€™s session â€” not others


ğŸ§  TL;DR:

| Scenario        | Cached? | Affects Others? | Impact                     |
| --------------- | ------- | --------------- | -------------------------- |
| Cached Response | âœ… Yes   | âœ… Yes           | Shared malicious response  |
| Not Cached      | âŒ No    | âŒ No            | Harmless, private response |


-

Exploiting web cache poisoning vulnerabilities

*In 2 ways:

   1. Exploiting cache design flaws
   2. Exploiting cache implementation flaws



ğŸ§± Flaws in Cache Design

> Problem in concept / logic

* These are high-level mistakes in how caching was intended to work.
* Example: A system chooses to exclude headers from the cache key (like `X-Forwarded-Host`) even though they affect responses.
* Another example: Caching user-specific content without thinking about access control.

ğŸ” Focus: *"What should be cached?"* and *"Based on what inputs?"*


ğŸ› ï¸ Flaws in Cache Implementation

> Problem in code / behavior

* These are bugs or oversights in the actual software that runs the cache.
* Example: The cache claims to consider a header in the key, but doesnâ€™t due to a coding error.
* Or: Cache ignores `Cache-Control: no-store` due to misparsing.

ğŸ” Focus: *"Does the cache work as designed?"*


 âœ… TL;DR:

| Type                    | Meaning                               | Example                              |
| ----------------------- | ------------------------------------- | ------------------------------------ |
| Design Flaw         | Bad decision in how caching works | Caching sensitive data for all users |
| Implementation Flaw | Bug in how caching is built       | Header ignored due to parsing bug    |

-

*

1. Exploiting cache design flaws

In short, websites are vulnerable to web cache poisoning if they handle unkeyed input in an unsafe way and allow the subsequent HTTP responses to be cached. 
This vulnerability can be used as a delivery method for a variety of different attacks. 



a> Using web cache poisoning to deliver an XSS attack

Perhaps the simplest web cache poisoning vulnerability to exploit is when unkeyed input is reflected in a cacheable response without proper sanitization.

For example, consider the following request and response:

GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: innocent-website.co.uk

HTTP/1.1 200 OK
Cache-Control: public
<meta property="og:image" content="https://innocent-website.co.uk/cms/social.png" />


Here, the value of the X-Forwarded-Host header is being used to dynamically generate an Open Graph image URL, which is then reflected in the response. 
Crucially for web cache poisoning, the X-Forwarded-Host header is often unkeyed. 



In this example, the cache can potentially be poisoned with a response containing a simple XSS payload:

GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"

HTTP/1.1 200 OK
Cache-Control: public
<meta property="og:image" content="https://a."><script>alert(1)</script>"/cms/social.png" />


*The prefix a. is used to make the whole string look like a valid domain name


If this response was cached, all users who accessed /en?region=uk would be served this XSS payload. 
This example simply causes an alert to appear in the victim's browser, but a real attack could potentially steal passwords and hijack user accounts. 



b> Using web cache poisoning to exploit unsafe handling of resource imports

Some websites use unkeyed headers to dynamically generate URLs for importing resources, such as externally hosted JavaScript files. 
In this case, if an attacker changes the value of the appropriate header to a domain that they control, they could potentially manipulate the URL to point to their own malicious JavaScript file instead.

If the response containing this malicious URL is cached, the attacker's JavaScript file would be imported and executed in the browser session of any user whose request has a matching cache key.

GET / HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: evil-user.net
User-Agent: Mozilla/5.0 Firefox/57.0

HTTP/1.1 200 OK
<script src="https://evil-user.net/static/analytics.js"></script>



c> Using web cache poisoning to exploit cookie-handling vulnerabilities


Web cache poisoning can exploit cookie-based logic if the cache ignores cookies.


ğŸ§ª Example:

ğŸ§© Two Parts Involved:

    Server logic â€” uses the cookie to generate personalized content.

    Cache logic â€” decides whether to store or reuse a response.


In this attack:


Step 1:

Attacker sends:

GET /blog/post.php?mobile=1 HTTP/1.1
Host: innocent-website.com
User-Agent: Mozilla/5.0 Firefox/57.0
Cookie: language=pl;
Connection: close

    âœ… Server sees language=pl â†’ returns Polish content.

    âŒ Cache sees only the URL and Host (not the Cookie) â†’ caches the Polish response.



Step 2:

Now anyone else who visits:

GET /blog/post.php?mobile=1 HTTP/1.1
Host: innocent-website.com
User-Agent: Mozilla/5.0 Firefox/57.0
Cookie: language=en;
Connection: close


    Server wants to give English.

    But the cache hits and sends the Polish version, because:

        The cache key is only /blog/post.php?mobile=1

        The cookie wasnâ€™t part of the key, so cache doesnâ€™t know there's a difference.


âœ… Summary:

    The cache never cared about the cookie â€” it cached the first response (Polish) and reused it for everyone, even if their cookie says otherwise.



d> Using multiple headers to exploit web cache poisoning vulnerabilities


Some sites need more advanced cache poisoning â€” especially when multiple unkeyed inputs are used.

Example:

```
GET /random HTTP/1.1  
Host: innocent-site.com  
X-Forwarded-Proto: http
```

Response:

```
HTTP/1.1 301 Moved Permanently  
Location: https://innocent-site.com/random
```

This redirect seems fine. But if the `Location` header is built from user input and the response is cached, an attacker can poison the cache to redirect users to a malicious site.


*X-Forwarded-Proto tells the backend what protocol (HTTP or HTTPS) the client originally used.



e> Exploiting responses that expose too much information

Some websites make cache poisoning easier by exposing internal behavior.


ğŸ“¦ Cache-control directives

If responses show cache details like:

HTTP/1.1 200 OK
Via: 1.1 varnish-v4
Age: 174
Cache-Control: public, max-age=1800


â€” attackers know when to send payloads to get them cached, avoiding trial-and-error or suspicious traffic.


ğŸ¯ Vary header

The Vary header tells the cache to use certain headers (like User-Agent) in the cache key.

Attackers can:

    Target specific browsers/devices.

    Choose the most common User-Agent to reach more users.

This helps create precise or large-scale cache poisoning attacks.






2. Exploiting cache implementation flaws

-



