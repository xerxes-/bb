It is a type of attack where an attacker tricks a website into storing private or sensitive information in a public cache (like a CDN or proxy), which anyone can then access.

-

ðŸ” Simple Example:

Imagine a website has a "My Account" page at:

https://example.com/account

This page is meant only for logged-in users, and should never be cached because it shows personal data.


Now the attacker tricks the site by visiting a fake URL like:

https://example.com/account/random.jpg

    The site still shows the account page, because it ignores the fake .jpg.

    The web cache sees .jpg and thinks it's a static file, so it stores the page.

    Now if anyone else visits that same URL, they see the attacker's account info!

-

Web caches

A web cache is a system (CDN or proxy server) that sits between the origin server and the user. 
When a client requests a static resource, the request is first directed to the cache. 
If the cache doesn't contain a copy of the resource (known as a cache miss), the request is forwarded to the origin server, which processes and responds to the request. 
The response is then sent to the cache before being sent to the user. 
The cache uses a preconfigured set of rules to determine whether to store the response.

When a request for the same static resource is made in the future, the cache serves the stored copy of the response directly to the user (known as a cache hit). 

-

Cache Rules

They tell browsers or proxy servers (like CDNs) what content to store, how long to store it, and who can use it.

They are controlled using HTTP headers, mainly:

    Cache-Control

    Expires

    ETag

    Last-Modified

-

ðŸ“¦ Common Cache-Control Rules:

Rule	                    What it Means	                                Example

no-store	                Donâ€™t save it at all	                        Login pages
no-cache	                Revalidate before using	                        Dynamic data
private	                    Only browser can cache	                        User dashboard
public	                    Can be cached by anyone	                        Images, CSS
max-age=3600	            Cache for 1 hour	                            Static assets
s-maxage=3600	            Cache for 1 hour on shared (proxy) cache	    CDN-level caching



ðŸ§  Example:

1. Static file (CSS or image):

Cache-Control: public, max-age=86400

    Cache this publicly for 1 day (86400 seconds).

2. User-specific page (like /account):

Cache-Control: private, no-store

    Donâ€™t cache this or let others store it â€” itâ€™s sensitive.

-

ðŸš« Misuse Example (Web Cache Deception):

If a private page returns:

Cache-Control: public

â€¦then the sensitive info can be cached, leading to leaks.

-

Cache keys

When the cache receives an HTTP request, it must decide whether there is a cached response that it can serve directly, or whether 
it has to forward the request to the origin server. 
The cache makes this decision by generating a 'cache key' from elements of the HTTP request. 
Typically, this includes the URL path and query parameters, but it can also include a variety of other elements like headers and content type.

If the incoming request's cache key matches that of a previous request, the cache considers them to be equivalent and serves a copy of the cached response. 

-

âœ… In simple terms:

    Cache Key = How the cache identifies a request (like a lookup key).

    Cache Rule (Headers) = Decides if the response can be stored and reused.


ðŸ§  Step-by-Step:

ðŸªª 1. Cache Key is used first (to look up)

When a request comes in, the cache (like a CDN or browser) builds a cache key based on things like:

    URL

    Query string

    HTTP method

    Headers (sometimes Accept, Authorization, etc.)

    It checks: "Have I seen this before?"


ðŸ§¾ 2. Cache Rules (headers) are checked

If there is a match, the cache looks at the response's cache rules like:

    Cache-Control

    Expires

    ETag

    It asks: "Am I allowed to reuse this response?"


ðŸ§° Example:

Request:

GET /account/profile.jpg

If cache key is just the URL (/account/profile.jpg)...


And response says:

Cache-Control: public, max-age=600

Then it might get cached publicly, even if it shows private data, leading to web cache deception.

-

Q.  (like a CDN or browser)  why you mentioned browser?

âœ… Why Browser Cache Matters:

A browser also stores responses to speed up page loads.

    If you visit a site, the browser cache can reuse static files (like CSS, JS, images) instead of re-downloading them.

    It uses the same cache headers: Cache-Control, ETag, etc.

    It respects rules like private, no-store, and max-age.


So when I said â€œcache like a CDN or browserâ€, I meant:

    Browser cache is private (only for that user).

    CDN or reverse proxy cache is shared (may serve cached content to many users).


âš ï¸ Why it matters in security:

If a sensitive page is cached by a shared cache (CDN), it's dangerous.
If cached by a browser, it's safer â€” because only that user can see it.

    Thatâ€™s why we use Cache-Control: private to tell: â€œOkay for browser, but NOT for CDN.â€

-

ðŸ’¡ Cache Flow Summary:

    User requests URL â†’ CDN checks for cached copy.

    Cache hit â†’ Serve from CDN (fast).

    Cache miss â†’ Go to origin â†’ Serve to user â†’ Maybe cache it (if rules allow).


ðŸ” Why this matters in security:

    On a cache miss, if the CDN caches a page that contains user-specific data, and later serves that to others (on a cache hit) â†’ Web Cache Deception or Leakage.

-

â“If a response has Cache-Control: no-store, does it still go through the CDN?

âœ… Yes, it goes through the CDN â€” but it wonâ€™t be cached.

-

Constructing a web cache deception attack

1. Identify a target endpoint that returns a dynamic response containing sensitive information. 
Review responses in Burp, as some sensitive information may not be visible on the rendered page. 
Focus on endpoints that support the GET, HEAD, or OPTIONS methods as requests that alter the origin server's state are generally not cached.

2. Identify a discrepancy in how the cache and origin server parse the URL path. This could be a discrepancy in how they:
        Map URLs to resources.
        Process delimiter characters.
        Normalize paths.
    
3. Craft a malicious URL that uses the discrepancy to trick the cache into storing a dynamic response. 
When the victim accesses the URL, their response is stored in the cache. 
Using Burp, you can then send a request to the same URL to fetch the cached response containing the victim's data. 
Avoid doing this directly in the browser as some applications redirect users without a session or invalidate local data, which could hide a vulnerability.

-

*Using a cache buster

While testing for discrepancies and crafting a web cache deception exploit, make sure that each request you send has a different cache key. 
Otherwise, you may be served cached responses, which will impact your test results.

As both URL path and any query parameters are typically included in the cache key, you can change the key by adding a query string to the path and changing it each time you send a request. 
Automate this process using the Param Miner extension. 
To do this, once you've installed the extension, click on the top-level Param miner > Settings menu, then select Add dynamic cachebuster. 
Burp now adds a unique query string to every request that you make. You can view the added query strings in the Logger tab. 

-

*Detecting cached responses

During testing, it's crucial that you're able to identify cached responses. To do so, look at response headers and response times.

Various response headers may indicate that it is cached. For example:

The X-Cache header provides information about whether a response was served from the cache. Typical values include:

==> X-Cache: hit - The response was served from the cache.

==> X-Cache: miss - The cache did not contain a response for the request's key, so it was fetched from the origin server. 
In most cases, the response is then cached. To confirm this, send the request again to see whether the value updates to hit.
    
==> X-Cache: dynamic - The origin server dynamically generated the content. Generally this means the response is not suitable for caching.
        
==> X-Cache: refresh - The cached content was outdated and needed to be refreshed or revalidated.
    
The Cache-Control header may include a directive that indicates caching, like public with a max-age higher than 0. 
Note that this only suggests that the resource is cacheable. 
It isn't always indicative of caching, as the cache may sometimes override this header.

If you notice a big difference in response time for the same request, this may also indicate that the faster response is served from the cache. 

--

Vulns:

1. Exploiting static extension cache rules

CDNs often cache content based on file extensions like .css or .js, assuming they're static. 
If the cache and origin server interpret URLs differentlyâ€”especially with how paths or delimiters are handledâ€”an attacker can exploit this mismatch.

For example, a dynamic resource can be requested using a static-looking extension that the origin server ignores but the cache accepts, potentially leading to Web Cache Deception.

Path Mapping Discrepancies

URL path mapping links URL paths to server resources and varies by framework. Two main types are:

    a> Traditional Mapping: Maps directly to file system paths (e.g. /path/resource.html).

    b> REST-style Mapping: Uses logical endpoints and parameters (e.g. /user/123/profile).



In a mismatch scenario:

http://example.com/user/123/profile/wcd.css

    - The origin server (using REST-style) treats it as a request for /user/123/profile, ignoring wcd.css.

    - The cache (using traditional mapping) sees it as /user/123/profile/wcd.css and may cache the dynamic profile data as if it were a .css file.


This results in sensitive dynamic data being cached and served to unintended users.


1.1 Exploiting path mapping discrepancies

To test how the origin server maps the URL path to resources, add an arbitrary path segment to the URL of your target endpoint. 
If the response still contains the same sensitive data as the base response, it indicates that the origin server abstracts the URL path and ignores the added segment. 
For example, this is the case if modifying /api/orders/123 to /api/orders/123/foo still returns order information.

To test how the cache maps the URL path to resources, you'll need to modify the path to attempt to match a cache rule by adding a static extension. 
For example, update /api/orders/123/foo to /api/orders/123/foo.js. If the response is cached, this indicates:

    > That the cache interprets the full URL path with the static extension.
    > That there is a cache rule to store responses for requests ending in .js.

Caches may have rules based on specific static extensions. Try a range of extensions, including .css, .ico, and .exe.

You can then craft a URL that returns a dynamic response that is stored in the cache. 
Note that this attack is limited to the specific endpoint that you tested, as the origin server often has different abstraction rules for different endpoints. 

-

Delimiter Discrepancies in Web Cache Deception

Delimiters (like ?, ;, ., %00) define boundaries in URLs. 
While some are standardized, different frameworks interpret them differently, which can lead to cache deception vulnerabilities.

Example 1: ; Delimiter (Java Spring)
URL: /profile;foo.css

    > Origin server (Spring) treats ; as a matrix variable delimiter, truncates at /profile, and returns profile info.

    > Cache may treat ;foo.css as part of the path, see .css, and cache the profile response as a CSS file.


Example 2: . Delimiter (Ruby on Rails)

    /profile â†’ returns HTML profile.

    /profile.css â†’ unrecognized formatter, returns error.

    /profile.ico â†’ .ico not recognized, defaults to HTML response.

If the cache stores .ico responses, it could wrongly cache and serve the HTML profile data as a static icon.


Example 3: Encoded %00 Null Byte (OpenLiteSpeed)
URL: /profile%00foo.js

    > OpenLiteSpeed treats %00 as a delimiter, interprets path as /profile.

    > Other frameworks may error out, but caches (e.g., Akamai, Fastly) may treat %00foo.js as the full path and cache the response.



1.2 Exploiting Delimiter Discrepancies

You can exploit delimiter differences between the origin server and cache to add a fake static extension (like .js or .css) that tricks the cache but is ignored by the server.

Step-by-Step:

    a) Find Delimiters Used by the Origin Server:

        - Add a random string to a URL (e.g., /settings/users/listaaa) and note the response.

        - Then try adding a delimiter before the string (e.g., /settings/users/list;aaa).

        - If the response matches the original /settings/users/list, the server is treating ; as a delimiter.


    b) Check if the Cache Ignores the Delimiter:

        - Add a static extension (e.g., /settings/users/list;aaa.js).

        - If the response is cached, it means:

             > The cache sees the full path (including .js).

             > The origin server ignores .js and returns dynamic content.

        - This causes the cache to store and serve sensitive data as if it were a static file.


Notes:

    Test various delimiters (;, ., %00, etc.) and extensions (.css, .ico, .exe, etc.).

    Use Burp Intruder to automate testing. Disable automatic encoding to test raw characters.

    This technique often works across multiple endpoints once a working delimiter is found.


Browser Warning: Some characters (<, >, {, }, #) may be URL-encoded or blocked by the browser. Use encoded versions if needed.


Q. Why are we testing this /settings/users/listaaa

A. We test something like /settings/users/listaaa as a control step to understand how the origin server handles unexpected or malformed URLs.

Here's why:

    a) Baseline Behavior Check

        When you try /settings/users/listaaa, you're adding an unexpected string to a valid path.

        If the server responds exactly like /settings/users/list, it may be ignoring the extra string or redirecting to a clean URL.

        If the response is different (like an error or 404), it means the server treats it as a separate path.


    b) Helps Test Delimiters

    Once you know how the server reacts to a broken path:

        You add a delimiter: /settings/users/list;aaa

        Then compare its response to /settings/users/list and /settings/users/listaaa

        If it matches /settings/users/list, then the server is treating ; as a delimiter and ignoring the part after it.

-

Delimiter Decoding Discrepancies

URLs often contain special characters (like #, ?) that are URL-encoded (e.g., %23, %3f) to be treated as data. 
However, some servers decode these characters before processing, which can cause the URL path to be truncated if a delimiter is revealed.

If the cache and origin server decode differently, they may interpret the same URL in different ways, leading to cache deception.


Example 1: /profile%23wcd.css

    > Origin server decodes %23 to # and treats it as a delimiter â†’ returns /profile data.

    > Cache doesnâ€™t decode %23 â†’ sees full path /profile%23wcd.css â†’ may cache response as .css.


Example 2: /myaccount%3fwcd.css

    > Cache checks .css extension in /myaccount%3fwcd.css, decides to store it.

    > Then decodes %3f to ? and forwards /myaccount?wcd.css to the origin.

    > Origin server sees ? as a delimiter â†’ serves data for /myaccount.


"Decides to store it" means:

The cache server first receives the response from the origin server, and then decides whether to store it.


So the actual flow is:

    > Client sends: /myaccount%3fwcd.css

    > Cache sees .css, flags this URL as possibly cacheable based on its rules.

    > Cache decodes %3f â†’ ? and sends /myaccount?wcd.css to the origin server

    > Origin server interprets it as a request to /myaccount with query wcd.css, and returns sensitive user data.

    > Cache gets the response and, because the original URL looked like a .css file and caching is allowed, it stores that sensitive response under /myaccount%3fwcd.css



ðŸ” So to answer your earlier question:

    â“ At a time, only one server decodes â€” right?

âœ… Yes, in most real-world cases, only one server decodes a specific character â€” either:

    The cache decodes before forwarding, or

    The origin receives the raw encoded URL and decodes it internally

ðŸ›‘ They donâ€™t both decode the same character independently â€” because once it's decoded, it doesn't stay encoded.



1.3 Exploiting delimiter decoding discrepancies

Use the same testing methodology you used to identify and exploit delimiter discrepancies, but use a range of encoded characters. 
Make sure that you also test encoded non-printable characters, particularly %00, %0A and %09. 
If these characters are decoded they can also truncate the URL path. 

--

2. Exploiting static directory cache rules

It's common practice for web servers to store static resources in specific directories. 
Cache rules often target these directories by matching specific URL path prefixes, like /static, /assets, /scripts, or /images. 
These rules can also be vulnerable to web cache deception. 


Normalization discrepancies

Normalization involves converting various representations of URL paths into a standardized format. 
This sometimes includes decoding encoded characters and resolving dot-segments, but this varies significantly from parser to parser.

Discrepancies in how the cache and origin server normalize the URL can enable an attacker to construct a path traversal payload that is interpreted differently by each parser. 

Consider the example /static/..%2fprofile:

> An origin server that decodes slash characters and resolves dot-segments would normalize the path to /profile and return profile information.
A cache that doesn't resolve dot-segments or decode slashes would interpret the path as /static/..%2fprofile. 

> If the cache stores responses for requests with the /static prefix, it would cache and serve the profile information.



Detecting URL Normalization by the Origin Server

To check if the origin server normalizes the URL path, use a non-cacheable request (like POST) and add a path like /aaa/..%2fprofile.
Example:

Test /profile vs. /aaa/..%2fprofile
(%2f = /)

    If the response matches /profile â†’ the server decoded %2f and resolved .. â†’ path became /profile

    If it returns an error or different response â†’ the server did not decode or normalize the path

This helps identify how the origin server handles encoded slashes and dot segments.




Note:
When testing for normalization, start by encoding only the second slash in the dot-segment. This is important because some CDNs match the slash following the static directory prefix.
You can also try encoding the full path traversal sequence, or encoding a dot instead of the slash. This can sometimes impact whether the parser decodes the sequence.




Detecting Normalization by the Cache Server

1. Find Cached Static Files
   In Burp's HTTP history, filter for `2xx` responses and static file types (like `.js`, `.css`, images) to spot cached resources in common static directories (e.g., `/assets/`).

2. Test With Path Traversal (Before Directory)
   Modify a cached URL like:
   `/assets/js/stockCheck.js` â†’ `/aaa/..%2fassets/js/stockCheck.js`

   * If response is not cached â†’ Cache did not normalize the path
   * If still cached â†’ Cache likely normalized to `/assets/js/stockCheck.js`

3. Test With Path Traversal (Inside Directory)
   Try:
   `/assets/js/stockCheck.js` â†’ `/assets/..%2fjs/stockCheck.js`

   * If response is not cached â†’ Cache normalized to `/js/stockCheck.js`
   * If still cached â†’ Cache did not normalize



âœ… Now what do the results mean?

Response	        What it Means

Not Cached	        Cache decoded %2f to / and resolved .., turning the path into /js/stockCheck.js â€” which is a different path from the original, so itâ€™s not cached.
Still Cached	    Cache did not decode %2f or resolve .., so it treated the path literally as /assets/..%2fjs/stockCheck.js â€” which it thinks is the same or similar to the original, so it's still cached.



4. Confirm Directory-Based Caching
   Replace filename with garbage: `/assets/aaa`

   * If cached â†’ Cache rule is likely based on `/assets`
   * If not cached â†’ May still be cached, but 404 responses are often not stored





2.1 Exploiting normalization by the origin server

If the origin server resolves encoded dot-segments, but the cache doesn't, you can attempt to exploit the discrepancy by constructing a payload according to the following structure:
/<static-directory-prefix>/..%2f<dynamic-path>

For example, consider the payload /assets/..%2fprofile:

    The cache interprets the path as: /assets/..%2fprofile
    The origin server interprets the path as: /profile

The origin server returns the dynamic profile information, which is stored in the cache. 



2.2 Exploiting normalization by the cache server

If the cache server resolves encoded dot-segments but the origin server doesn't, you can attempt to exploit the discrepancy by constructing a payload according to the following structure:
/<dynamic-path>%2f%2e%2e%2f<static-directory-prefix>


Note:
When exploiting normalization by the cache server, encode all characters in the path traversal sequence. 


In this situation, path traversal alone isn't sufficient for an exploit. For example, consider how the cache and origin server interpret the payload /profile%2f%2e%2e%2fstatic:

    The cache interprets the path as: /static
    The origin server interprets the path as: /profile%2f%2e%2e%2fstatic

The origin server is likely to return an error message instead of profile information.

To exploit this discrepancy, you'll need to also identify a delimiter that is used by the origin server but not the cache. Test possible delimiters by adding them to the payload after the dynamic path:

    If the origin server uses a delimiter, it will truncate the URL path and return the dynamic information.
    If the cache doesn't use the delimiter, it will resolve the path and cache the response.


For example, consider the payload /profile;%2f%2e%2e%2fstatic. The origin server uses ; as a delimiter:

    The cache interprets the path as: /static
    The origin server interprets the path as: /profile

The origin server returns the dynamic profile information, which is stored in the cache. You can therefore use this payload for an exploit. 

















