It is a type of attack where an attacker tricks a website into storing private or sensitive information in a public cache (like a CDN or proxy), which anyone can then access.

-

ðŸ” Simple Example:

Imagine a website has a "My Account" page at:

https://example.com/account

This page is meant only for logged-in users, and should never be cached because it shows personal data.


Now the attacker tricks the site by visiting a fake URL like:

https://example.com/account/random.jpg

    The site still shows the account page, because it ignores the fake .jpg.

    The web cache sees .jpg and thinks it's a static file, so it stores the page.

    Now if anyone else visits that same URL, they see the attacker's account info!

-

Web caches

A web cache is a system (CDN or proxy server) that sits between the origin server and the user. 
When a client requests a static resource, the request is first directed to the cache. 
If the cache doesn't contain a copy of the resource (known as a cache miss), the request is forwarded to the origin server, which processes and responds to the request. 
The response is then sent to the cache before being sent to the user. 
The cache uses a preconfigured set of rules to determine whether to store the response.

When a request for the same static resource is made in the future, the cache serves the stored copy of the response directly to the user (known as a cache hit). 

-

Cache Rules

They tell browsers or proxy servers (like CDNs) what content to store, how long to store it, and who can use it.

They are controlled using HTTP headers, mainly:

    Cache-Control

    Expires

    ETag

    Last-Modified

-

ðŸ“¦ Common Cache-Control Rules:

Rule	                    What it Means	                                Example

no-store	                Donâ€™t save it at all	                        Login pages
no-cache	                Revalidate before using	                        Dynamic data
private	                    Only browser can cache	                        User dashboard
public	                    Can be cached by anyone	                        Images, CSS
max-age=3600	            Cache for 1 hour	                            Static assets
s-maxage=3600	            Cache for 1 hour on shared (proxy) cache	    CDN-level caching



ðŸ§  Example:

1. Static file (CSS or image):

Cache-Control: public, max-age=86400

    Cache this publicly for 1 day (86400 seconds).

2. User-specific page (like /account):

Cache-Control: private, no-store

    Donâ€™t cache this or let others store it â€” itâ€™s sensitive.

-

ðŸš« Misuse Example (Web Cache Deception):

If a private page returns:

Cache-Control: public

â€¦then the sensitive info can be cached, leading to leaks.

-

Cache keys

When the cache receives an HTTP request, it must decide whether there is a cached response that it can serve directly, or whether 
it has to forward the request to the origin server. 
The cache makes this decision by generating a 'cache key' from elements of the HTTP request. 
Typically, this includes the URL path and query parameters, but it can also include a variety of other elements like headers and content type.

If the incoming request's cache key matches that of a previous request, the cache considers them to be equivalent and serves a copy of the cached response. 

-

âœ… In simple terms:

    Cache Key = How the cache identifies a request (like a lookup key).

    Cache Rule (Headers) = Decides if the response can be stored and reused.


ðŸ§  Step-by-Step:

ðŸªª 1. Cache Key is used first (to look up)

When a request comes in, the cache (like a CDN or browser) builds a cache key based on things like:

    URL

    Query string

    HTTP method

    Headers (sometimes Accept, Authorization, etc.)

    It checks: "Have I seen this before?"


ðŸ§¾ 2. Cache Rules (headers) are checked

If there is a match, the cache looks at the response's cache rules like:

    Cache-Control

    Expires

    ETag

    It asks: "Am I allowed to reuse this response?"


ðŸ§° Example:

Request:

GET /account/profile.jpg

If cache key is just the URL (/account/profile.jpg)...


And response says:

Cache-Control: public, max-age=600

Then it might get cached publicly, even if it shows private data, leading to web cache deception.

-

Q.  (like a CDN or browser)  why you mentioned browser?

âœ… Why Browser Cache Matters:

A browser also stores responses to speed up page loads.

    If you visit a site, the browser cache can reuse static files (like CSS, JS, images) instead of re-downloading them.

    It uses the same cache headers: Cache-Control, ETag, etc.

    It respects rules like private, no-store, and max-age.


So when I said â€œcache like a CDN or browserâ€, I meant:

    Browser cache is private (only for that user).

    CDN or reverse proxy cache is shared (may serve cached content to many users).


âš ï¸ Why it matters in security:

If a sensitive page is cached by a shared cache (CDN), it's dangerous.
If cached by a browser, it's safer â€” because only that user can see it.

    Thatâ€™s why we use Cache-Control: private to tell: â€œOkay for browser, but NOT for CDN.â€

-

ðŸ’¡ Cache Flow Summary:

    User requests URL â†’ CDN checks for cached copy.

    Cache hit â†’ Serve from CDN (fast).

    Cache miss â†’ Go to origin â†’ Serve to user â†’ Maybe cache it (if rules allow).


ðŸ” Why this matters in security:

    On a cache miss, if the CDN caches a page that contains user-specific data, and later serves that to others (on a cache hit) â†’ Web Cache Deception or Leakage.

-

â“If a response has Cache-Control: no-store, does it still go through the CDN?

âœ… Yes, it goes through the CDN â€” but it wonâ€™t be cached.

-

Constructing a web cache deception attack

1. Identify a target endpoint that returns a dynamic response containing sensitive information. 
Review responses in Burp, as some sensitive information may not be visible on the rendered page. 
Focus on endpoints that support the GET, HEAD, or OPTIONS methods as requests that alter the origin server's state are generally not cached.

2. Identify a discrepancy in how the cache and origin server parse the URL path. This could be a discrepancy in how they:
        Map URLs to resources.
        Process delimiter characters.
        Normalize paths.
    
3. Craft a malicious URL that uses the discrepancy to trick the cache into storing a dynamic response. 
When the victim accesses the URL, their response is stored in the cache. 
Using Burp, you can then send a request to the same URL to fetch the cached response containing the victim's data. 
Avoid doing this directly in the browser as some applications redirect users without a session or invalidate local data, which could hide a vulnerability.

-

*Using a cache buster

While testing for discrepancies and crafting a web cache deception exploit, make sure that each request you send has a different cache key. 
Otherwise, you may be served cached responses, which will impact your test results.

As both URL path and any query parameters are typically included in the cache key, you can change the key by adding a query string to the path and changing it each time you send a request. 
Automate this process using the Param Miner extension. 
To do this, once you've installed the extension, click on the top-level Param miner > Settings menu, then select Add dynamic cachebuster. 
Burp now adds a unique query string to every request that you make. You can view the added query strings in the Logger tab. 

-

*Detecting cached responses

During testing, it's crucial that you're able to identify cached responses. To do so, look at response headers and response times.

Various response headers may indicate that it is cached. For example:

The X-Cache header provides information about whether a response was served from the cache. Typical values include:

==> X-Cache: hit - The response was served from the cache.

==> X-Cache: miss - The cache did not contain a response for the request's key, so it was fetched from the origin server. 
In most cases, the response is then cached. To confirm this, send the request again to see whether the value updates to hit.
    
==> X-Cache: dynamic - The origin server dynamically generated the content. Generally this means the response is not suitable for caching.
        
==> X-Cache: refresh - The cached content was outdated and needed to be refreshed or revalidated.
    
The Cache-Control header may include a directive that indicates caching, like public with a max-age higher than 0. 
Note that this only suggests that the resource is cacheable. 
It isn't always indicative of caching, as the cache may sometimes override this header.

If you notice a big difference in response time for the same request, this may also indicate that the faster response is served from the cache. 

--

Vulns:

1. Exploiting static extension cache rules

CDNs often cache content based on file extensions like .css or .js, assuming they're static. 
If the cache and origin server interpret URLs differentlyâ€”especially with how paths or delimiters are handledâ€”an attacker can exploit this mismatch.

For example, a dynamic resource can be requested using a static-looking extension that the origin server ignores but the cache accepts, potentially leading to Web Cache Deception.

Path Mapping Discrepancies

URL path mapping links URL paths to server resources and varies by framework. Two main types are:

    a> Traditional Mapping: Maps directly to file system paths (e.g. /path/resource.html).

    b> REST-style Mapping: Uses logical endpoints and parameters (e.g. /user/123/profile).



In a mismatch scenario:

http://example.com/user/123/profile/wcd.css

    - The origin server (using REST-style) treats it as a request for /user/123/profile, ignoring wcd.css.

    - The cache (using traditional mapping) sees it as /user/123/profile/wcd.css and may cache the dynamic profile data as if it were a .css file.


This results in sensitive dynamic data being cached and served to unintended users.


1.1 Exploiting path mapping discrepancies

To test how the origin server maps the URL path to resources, add an arbitrary path segment to the URL of your target endpoint. 
If the response still contains the same sensitive data as the base response, it indicates that the origin server abstracts the URL path and ignores the added segment. 
For example, this is the case if modifying /api/orders/123 to /api/orders/123/foo still returns order information.

To test how the cache maps the URL path to resources, you'll need to modify the path to attempt to match a cache rule by adding a static extension. 
For example, update /api/orders/123/foo to /api/orders/123/foo.js. If the response is cached, this indicates:

    > That the cache interprets the full URL path with the static extension.
    > That there is a cache rule to store responses for requests ending in .js.

Caches may have rules based on specific static extensions. Try a range of extensions, including .css, .ico, and .exe.

You can then craft a URL that returns a dynamic response that is stored in the cache. 
Note that this attack is limited to the specific endpoint that you tested, as the origin server often has different abstraction rules for different endpoints. 

-

Delimiter Discrepancies in Web Cache Deception

Delimiters (like ?, ;, ., %00) define boundaries in URLs. 
While some are standardized, different frameworks interpret them differently, which can lead to cache deception vulnerabilities.

Example 1: ; Delimiter (Java Spring)
URL: /profile;foo.css

    > Origin server (Spring) treats ; as a matrix variable delimiter, truncates at /profile, and returns profile info.

    > Cache may treat ;foo.css as part of the path, see .css, and cache the profile response as a CSS file.


Example 2: . Delimiter (Ruby on Rails)

    /profile â†’ returns HTML profile.

    /profile.css â†’ unrecognized formatter, returns error.

    /profile.ico â†’ .ico not recognized, defaults to HTML response.

If the cache stores .ico responses, it could wrongly cache and serve the HTML profile data as a static icon.


Example 3: Encoded %00 Null Byte (OpenLiteSpeed)
URL: /profile%00foo.js

    > OpenLiteSpeed treats %00 as a delimiter, interprets path as /profile.

    > Other frameworks may error out, but caches (e.g., Akamai, Fastly) may treat %00foo.js as the full path and cache the response.



1.2 Exploiting Delimiter Discrepancies

You can exploit delimiter differences between the origin server and cache to add a fake static extension (like .js or .css) that tricks the cache but is ignored by the server.

Step-by-Step:

    a) Find Delimiters Used by the Origin Server:

        - Add a random string to a URL (e.g., /settings/users/listaaa) and note the response.

        - Then try adding a delimiter before the string (e.g., /settings/users/list;aaa).

        - If the response matches the original /settings/users/list, the server is treating ; as a delimiter.


    b) Check if the Cache Ignores the Delimiter:

        - Add a static extension (e.g., /settings/users/list;aaa.js).

        - If the response is cached, it means:

             > The cache sees the full path (including .js).

             > The origin server ignores .js and returns dynamic content.

        - This causes the cache to store and serve sensitive data as if it were a static file.


Notes:

    Test various delimiters (;, ., %00, etc.) and extensions (.css, .ico, .exe, etc.).

    Use Burp Intruder to automate testing. Disable automatic encoding to test raw characters.

    This technique often works across multiple endpoints once a working delimiter is found.


Browser Warning: Some characters (<, >, {, }, #) may be URL-encoded or blocked by the browser. Use encoded versions if needed.


Q. Why are we testing this /settings/users/listaaa

A. We test something like /settings/users/listaaa as a control step to understand how the origin server handles unexpected or malformed URLs.

Here's why:

    a) Baseline Behavior Check

        When you try /settings/users/listaaa, you're adding an unexpected string to a valid path.

        If the server responds exactly like /settings/users/list, it may be ignoring the extra string or redirecting to a clean URL.

        If the response is different (like an error or 404), it means the server treats it as a separate path.


    b) Helps Test Delimiters

    Once you know how the server reacts to a broken path:

        You add a delimiter: /settings/users/list;aaa

        Then compare its response to /settings/users/list and /settings/users/listaaa

        If it matches /settings/users/list, then the server is treating ; as a delimiter and ignoring the part after it.

-










